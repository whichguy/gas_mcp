/**
 * GitConfigManager - Manages .git.gs configuration files for GAS projects
 * 
 * Provides safe creation, parsing, updating and validation of git configuration
 * stored in _git.gs files within Google Apps Script projects.
 */

export interface GitConfig {
  version: string;
  repository: string;
  branch: string;
  localPath: string;
  syncPrefix?: string;
  lastSync?: {
    timestamp: string;
    direction: 'init' | 'pull' | 'push' | 'sync';
    commitHash?: string;
    filesChanged?: number;
  };
  transformations?: Record<string, FileTransformation>;
  pathMappings?: Record<string, string>;
  specialFiles?: {
    hasReadme?: boolean;
    readmeFormat?: string;
    hasDotfiles?: string[];
  };
}

export interface FileTransformation {
  gasName: string;
  gasType: 'SERVER_JS' | 'HTML' | 'JSON';
  localPath: string;
  transformType: 'markdown-html' | 'text-module' | 'none';
}

export interface GitConfigParams {
  repository: string;
  branch: string;
  localPath: string;
  syncPrefix?: string;
  includeReadme?: boolean;
}

export class GitConfigManager {
  // Constants for file naming
  private static readonly GAS_NAME = '.git';  // Name in GAS (now using period prefix)
  private static readonly LOCAL_PATH = '.gasmodules/.git.gs';  // Local storage path
  private static readonly VERSION = '2.1';
  
  /**
   * Create a new git configuration file with CommonJS wrapper
   */
  static create(params: GitConfigParams): string {
    const timestamp = new Date().toISOString();
    
    // Build the config object
    const config: GitConfig = {
      version: this.VERSION,
      repository: params.repository,
      branch: params.branch,
      localPath: params.localPath,
      syncPrefix: params.syncPrefix || '',
      lastSync: {
        timestamp,
        direction: 'init',
        commitHash: '',
        filesChanged: 0
      },
      pathMappings: {},
      transformations: {
        'README': {
          gasName: 'README',
          gasType: 'HTML',
          localPath: 'README.md',
          transformType: 'markdown-html'
        },
        '.gitignore': {
          gasName: '.gitignore',
          gasType: 'SERVER_JS',
          localPath: '.gitignore',
          transformType: 'text-module'
        }
      },
      specialFiles: {
        hasReadme: params.includeReadme !== false,
        readmeFormat: 'markdown',
        hasDotfiles: []
      }
    };
    
    // Convert config to JavaScript source
    const configSource = this.configToSource(config);
    
    // Wrap in CommonJS module with correct signature
    return `function _main(
  module = globalThis.__getCurrentModule(),
  exports = module.exports,
  require = globalThis.require
) {
  /**
   * Git Configuration File
   * Generated by MCP GAS Server
   * Version: ${this.VERSION}
   * Created: ${timestamp}
   */
  
  const GIT_CONFIG = ${configSource};
  
  // Export configuration
  module.exports = GIT_CONFIG;
  
  // Helper functions for accessing config
  exports.getGitConfig = () => GIT_CONFIG;
  exports.isGitLinked = true;
  exports.getRepository = () => GIT_CONFIG.repository;
  exports.getBranch = () => GIT_CONFIG.branch;
  exports.getLocalPath = () => GIT_CONFIG.localPath;
}

__defineModule__(_main);`;
  }
  
  /**
   * Parse git configuration from GAS source code
   */
  static parse(source: string): GitConfig | null {
    if (!source) return null;
    
    try {
      // First unwrap CommonJS module if present
      const unwrapped = this.unwrapCommonJS(source);
      
      // Find the GIT_CONFIG object
      const configMatch = unwrapped.match(/const GIT_CONFIG = ({[\s\S]*?});/);
      if (!configMatch) return null;
      
      // Parse the configuration object safely
      return this.parseConfigObject(configMatch[1]);
    } catch (error) {
      console.error('Failed to parse git config:', error);
      return null;
    }
  }
  
  /**
   * Update existing configuration with new values
   */
  static update(config: GitConfig, updates: Partial<GitConfig>): string {
    const updated = { ...config, ...updates };
    
    // Update timestamp if lastSync was modified
    if (updates.lastSync) {
      updated.lastSync = {
        ...config.lastSync,
        ...updates.lastSync,
        timestamp: new Date().toISOString()
      };
    }
    
    return this.create({
      repository: updated.repository,
      branch: updated.branch,
      localPath: updated.localPath,
      syncPrefix: updated.syncPrefix,
      includeReadme: updated.specialFiles?.hasReadme
    });
  }
  
  /**
   * Validate git configuration
   */
  static validate(config: any): config is GitConfig {
    if (!config || typeof config !== 'object') return false;
    
    // Required string fields
    const requiredStrings = ['repository', 'branch', 'localPath'];
    for (const field of requiredStrings) {
      if (typeof config[field] !== 'string' || !config[field]) {
        return false;
      }
    }
    
    // Validate repository URL format
    if (!this.isValidRepositoryUrl(config.repository)) {
      return false;
    }
    
    // Validate branch name
    if (!this.isValidBranchName(config.branch)) {
      return false;
    }
    
    // Optional validations
    if (config.lastSync && typeof config.lastSync !== 'object') {
      return false;
    }
    
    return true;
  }
  
  /**
   * Get the GAS file name for the config
   */
  static getGasFileName(): string {
    return this.GAS_NAME;
  }
  
  /**
   * Get the local file path for the config
   */
  static getLocalPath(): string {
    return this.LOCAL_PATH;
  }
  
  // Private helper methods
  
  private static unwrapCommonJS(source: string): string {
    if (!source.includes('function _main(') || !source.includes('__defineModule__(_main)')) {
      return source;
    }
    
    const match = source.match(/function _main\([^)]*\)\s*{([\s\S]*?)}\s*\n\s*__defineModule__\(_main\);?/);
    return match ? match[1] : source;
  }
  
  private static parseConfigObject(configStr: string): GitConfig {
    const config: any = {};
    
    // Extract string fields
    const stringFields = ['version', 'repository', 'branch', 'localPath', 'syncPrefix'];
    for (const field of stringFields) {
      const regex = new RegExp(`${field}:\\s*['"]([^'"]*)['"]`);
      const match = configStr.match(regex);
      if (match) config[field] = match[1];
    }
    
    // Extract lastSync object
    const lastSyncMatch = configStr.match(/lastSync:\s*{([\s\S]*?)},/);
    if (lastSyncMatch) {
      config.lastSync = this.parseLastSync(lastSyncMatch[1]);
    }
    
    // Extract transformations
    const transformMatch = configStr.match(/transformations:\s*{([\s\S]*?)},\s*(?:pathMappings|specialFiles)/);
    if (transformMatch) {
      config.transformations = this.parseTransformations(transformMatch[1]);
    }
    
    // Extract pathMappings
    const pathMappingsMatch = configStr.match(/pathMappings:\s*{([\s\S]*?)},/);
    if (pathMappingsMatch) {
      config.pathMappings = this.parsePathMappings(pathMappingsMatch[1]);
    }
    
    // Extract specialFiles
    const specialFilesMatch = configStr.match(/specialFiles:\s*{([\s\S]*?)}/);
    if (specialFilesMatch) {
      config.specialFiles = this.parseSpecialFiles(specialFilesMatch[1]);
    }
    
    return config;
  }
  
  private static parseLastSync(content: string): GitConfig['lastSync'] {
    const lastSync: any = {};
    
    const timestampMatch = content.match(/timestamp:\s*['"]([^'"]*)['"]/);;
    const directionMatch = content.match(/direction:\s*['"]([^'"]*)['"]/);;
    const commitMatch = content.match(/commitHash:\s*['"]([^'"]*)['"]/);;
    const filesMatch = content.match(/filesChanged:\s*(\d+)/);
    
    if (timestampMatch) lastSync.timestamp = timestampMatch[1];
    if (directionMatch) lastSync.direction = directionMatch[1];
    if (commitMatch) lastSync.commitHash = commitMatch[1];
    if (filesMatch) lastSync.filesChanged = parseInt(filesMatch[1], 10);
    
    return lastSync;
  }
  
  private static parseTransformations(content: string): Record<string, FileTransformation> {
    const transformations: Record<string, FileTransformation> = {};
    
    // Match each transformation entry
    const fileMatches = content.matchAll(/['"]([^'"]+)['"]\s*:\s*{([^}]*)}/g);
    for (const [, fileName, fileConfig] of fileMatches) {
      transformations[fileName] = this.parseTransformation(fileConfig);
    }
    
    return transformations;
  }
  
  private static parseTransformation(content: string): FileTransformation {
    const transform: any = {};
    
    const gasNameMatch = content.match(/gasName:\s*['"]([^'"]*)['"]/);;
    const gasTypeMatch = content.match(/gasType:\s*['"]([^'"]*)['"]/);;
    const localPathMatch = content.match(/localPath:\s*['"]([^'"]*)['"]/);;
    const transformTypeMatch = content.match(/transformType:\s*['"]([^'"]*)['"]/);;
    
    if (gasNameMatch) transform.gasName = gasNameMatch[1];
    if (gasTypeMatch) transform.gasType = gasTypeMatch[1];
    if (localPathMatch) transform.localPath = localPathMatch[1];
    if (transformTypeMatch) transform.transformType = transformTypeMatch[1];
    
    return transform;
  }
  
  private static parsePathMappings(content: string): Record<string, string> {
    const mappings: Record<string, string> = {};
    
    if (!content.trim()) return mappings;
    
    const matches = content.matchAll(/['"]([^'"]+)['"]\s*:\s*['"]([^'"]+)['"]/g);
    for (const [, key, value] of matches) {
      mappings[key] = value;
    }
    
    return mappings;
  }
  
  private static parseSpecialFiles(content: string): GitConfig['specialFiles'] {
    const specialFiles: any = {};
    
    const hasReadmeMatch = content.match(/hasReadme:\s*(true|false)/);;
    const formatMatch = content.match(/readmeFormat:\s*['"]([^'"]*)['"]/);;
    const dotfilesMatch = content.match(/hasDotfiles:\s*\[([\s\S]*?)\]/);
    
    if (hasReadmeMatch) specialFiles.hasReadme = hasReadmeMatch[1] === 'true';
    if (formatMatch) specialFiles.readmeFormat = formatMatch[1];
    if (dotfilesMatch) {
      const dotfiles = dotfilesMatch[1].matchAll(/['"]([^'"]+)['"]/g);
      specialFiles.hasDotfiles = Array.from(dotfiles, m => m[1]);
    }
    
    return specialFiles;
  }
  
  private static configToSource(config: GitConfig): string {
    // Build JavaScript object literal as string
    const lines: string[] = ['{'];
    
    // Add simple string fields
    lines.push(`    version: "${config.version}",`);
    lines.push(`    repository: "${config.repository}",`);
    lines.push(`    branch: "${config.branch}",`);
    lines.push(`    localPath: "${config.localPath}",`);
    lines.push(`    syncPrefix: "${config.syncPrefix || ''}",`);
    
    // Add lastSync
    if (config.lastSync) {
      lines.push('    ');
      lines.push('    // Sync metadata');
      lines.push('    lastSync: {');
      lines.push(`      timestamp: "${config.lastSync.timestamp}",`);
      lines.push(`      direction: "${config.lastSync.direction}",`);
      lines.push(`      commitHash: "${config.lastSync.commitHash || ''}",`);
      lines.push(`      filesChanged: ${config.lastSync.filesChanged || 0}`);
      lines.push('    },');
    }
    
    // Add pathMappings
    lines.push('    ');
    lines.push('    // Path mappings for folder structure preservation');
    lines.push('    pathMappings: {},');
    
    // Add transformations
    if (config.transformations) {
      lines.push('    ');
      lines.push('    // File transformation mappings');
      lines.push('    transformations: {');
      for (const [name, transform] of Object.entries(config.transformations)) {
        lines.push(`      "${name}": {`);
        lines.push(`        gasName: "${transform.gasName}",`);
        lines.push(`        gasType: "${transform.gasType}",`);
        lines.push(`        localPath: "${transform.localPath}",`);
        lines.push(`        transformType: "${transform.transformType}"`);
        lines.push('      },');
      }
      // Remove trailing comma from last transformation
      if (lines[lines.length - 1].endsWith(',')) {
        lines[lines.length - 1] = lines[lines.length - 1].slice(0, -1);
      }
      lines.push('    },');
    }
    
    // Add specialFiles
    if (config.specialFiles) {
      lines.push('    ');
      lines.push('    // Special files tracking');
      lines.push('    specialFiles: {');
      lines.push(`      hasReadme: ${config.specialFiles.hasReadme || false},`);
      lines.push(`      readmeFormat: "${config.specialFiles.readmeFormat || 'markdown'}",`);
      lines.push(`      hasDotfiles: [${(config.specialFiles.hasDotfiles || []).map(f => `"${f}"`).join(', ')}]`);
      lines.push('    }');
    }
    
    lines.push('  }');
    
    return lines.join('\n');
  }
  
  private static isValidRepositoryUrl(url: string): boolean {
    if (url === 'local') return true;
    
    // Check for common git URL patterns
    const patterns = [
      /^https?:\/\/.+\.git$/,
      /^git@.+:.+\.git$/,
      /^ssh:\/\/.+\.git$/,
      /^https?:\/\/github\.com\/.+\/.+$/,
      /^https?:\/\/gitlab\.com\/.+\/.+$/,
      /^https?:\/\/bitbucket\.org\/.+\/.+$/
    ];
    
    return patterns.some(pattern => pattern.test(url));
  }
  
  private static isValidBranchName(branch: string): boolean {
    // Git branch name rules
    if (!branch || branch.length === 0) return false;
    if (branch.startsWith('.') || branch.startsWith('-')) return false;
    if (branch.endsWith('.') || branch.endsWith('.lock')) return false;
    if (branch.includes('..') || branch.includes('//')) return false;
    
    // Must contain only valid characters
    return /^[a-zA-Z0-9._\/-]+$/.test(branch);
  }
}